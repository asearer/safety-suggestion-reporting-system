{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { Platform } from 'expo-modules-core';\nexport var userMediaRequested = false;\nexport var mountedInstances = [];\nfunction requestLegacyUserMediaAsync(_x) {\n  return _requestLegacyUserMediaAsync.apply(this, arguments);\n}\nfunction _requestLegacyUserMediaAsync() {\n  _requestLegacyUserMediaAsync = _asyncToGenerator(function* (props) {\n    var optionalSource = function optionalSource(id) {\n      return {\n        optional: [{\n          sourceId: id\n        }]\n      };\n    };\n    var constraintToSourceId = function constraintToSourceId(constraint) {\n      var deviceId = constraint.deviceId;\n      if (typeof deviceId === 'string') {\n        return deviceId;\n      }\n      if (Array.isArray(deviceId)) {\n        var _deviceId$;\n        return (_deviceId$ = deviceId[0]) != null ? _deviceId$ : null;\n      } else if (typeof deviceId === 'object' && deviceId.ideal) {\n        return deviceId.ideal;\n      }\n      return null;\n    };\n    var sources = yield new Promise(function (resolve) {\n      return (MediaStreamTrack.getSources(function (sources) {\n          return resolve(sources);\n        })\n      );\n    });\n    var audioSource = null;\n    var videoSource = null;\n    sources.forEach(function (source) {\n      if (source.kind === 'audio') {\n        audioSource = source.id;\n      } else if (source.kind === 'video') {\n        videoSource = source.id;\n      }\n    });\n    var audioSourceId = constraintToSourceId(props.audioConstraints);\n    if (audioSourceId) {\n      audioSource = audioSourceId;\n    }\n    var videoSourceId = constraintToSourceId(props.videoConstraints);\n    if (videoSourceId) {\n      videoSource = videoSourceId;\n    }\n    return [optionalSource(audioSource), optionalSource(videoSource)];\n  });\n  return _requestLegacyUserMediaAsync.apply(this, arguments);\n}\nfunction sourceSelectedAsync(_x2, _x3, _x4) {\n  return _sourceSelectedAsync.apply(this, arguments);\n}\nfunction _sourceSelectedAsync() {\n  _sourceSelectedAsync = _asyncToGenerator(function* (isMuted, audioConstraints, videoConstraints) {\n    var constraints = {\n      video: typeof videoConstraints !== 'undefined' ? videoConstraints : true\n    };\n    if (!isMuted) {\n      constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n    }\n    return yield getAnyUserMediaAsync(constraints);\n  });\n  return _sourceSelectedAsync.apply(this, arguments);\n}\nexport function requestUserMediaAsync(_x5) {\n  return _requestUserMediaAsync.apply(this, arguments);\n}\nfunction _requestUserMediaAsync() {\n  _requestUserMediaAsync = _asyncToGenerator(function* (props) {\n    var isMuted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (canGetUserMedia()) {\n      return yield sourceSelectedAsync(isMuted, props.audio, props.video);\n    }\n    var _yield$requestLegacyU = yield requestLegacyUserMediaAsync(props),\n      _yield$requestLegacyU2 = _slicedToArray(_yield$requestLegacyU, 2),\n      audio = _yield$requestLegacyU2[0],\n      video = _yield$requestLegacyU2[1];\n    return yield sourceSelectedAsync(isMuted, audio, video);\n  });\n  return _requestUserMediaAsync.apply(this, arguments);\n}\nexport function getAnyUserMediaAsync(_x6) {\n  return _getAnyUserMediaAsync.apply(this, arguments);\n}\nfunction _getAnyUserMediaAsync() {\n  _getAnyUserMediaAsync = _asyncToGenerator(function* (constraints) {\n    var ignoreConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    try {\n      return yield getUserMediaAsync(_objectSpread(_objectSpread({}, constraints), {}, {\n        video: ignoreConstraints || constraints.video\n      }));\n    } catch (error) {\n      if (!ignoreConstraints && typeof error === 'object' && (error == null ? void 0 : error.name) === 'ConstraintNotSatisfiedError') {\n        return yield getAnyUserMediaAsync(constraints, true);\n      }\n      throw error;\n    }\n  });\n  return _getAnyUserMediaAsync.apply(this, arguments);\n}\nexport function getUserMediaAsync(_x7) {\n  return _getUserMediaAsync.apply(this, arguments);\n}\nfunction _getUserMediaAsync() {\n  _getUserMediaAsync = _asyncToGenerator(function* (constraints) {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      return navigator.mediaDevices.getUserMedia(constraints);\n    }\n    var _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n    return new Promise(function (resolve, reject) {\n      return _getUserMedia.call(navigator, constraints, resolve, reject);\n    });\n  });\n  return _getUserMediaAsync.apply(this, arguments);\n}\nexport function canGetUserMedia() {\n  return (Platform.isDOMAvailable && !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'])\n  );\n}\nexport function isFrontCameraAvailableAsync(_x8) {\n  return _isFrontCameraAvailableAsync.apply(this, arguments);\n}\nfunction _isFrontCameraAvailableAsync() {\n  _isFrontCameraAvailableAsync = _asyncToGenerator(function* (devices) {\n    return yield supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n  });\n  return _isFrontCameraAvailableAsync.apply(this, arguments);\n}\nexport function isBackCameraAvailableAsync(_x9) {\n  return _isBackCameraAvailableAsync.apply(this, arguments);\n}\nfunction _isBackCameraAvailableAsync() {\n  _isBackCameraAvailableAsync = _asyncToGenerator(function* (devices) {\n    return yield supportsCameraType(['back', 'rear'], 'environment', devices);\n  });\n  return _isBackCameraAvailableAsync.apply(this, arguments);\n}\nfunction supportsCameraType(_x0, _x1, _x10) {\n  return _supportsCameraType.apply(this, arguments);\n}\nfunction _supportsCameraType() {\n  _supportsCameraType = _asyncToGenerator(function* (labels, type, devices) {\n    if (!devices) {\n      if (!navigator.mediaDevices.enumerateDevices) {\n        return null;\n      }\n      devices = yield navigator.mediaDevices.enumerateDevices();\n    }\n    var cameras = devices.filter(function (t) {\n      return t.kind === 'videoinput';\n    });\n    var _cameras$filter = cameras.filter(function (camera) {\n        return labels.some(function (label) {\n          return camera.label.toLowerCase().includes(label);\n        });\n      }),\n      _cameras$filter2 = _slicedToArray(_cameras$filter, 1),\n      hasCamera = _cameras$filter2[0];\n    var _cameras$filter3 = cameras.filter(function (camera) {\n        if (!('getCapabilities' in camera)) {\n          return null;\n        }\n        var capabilities = camera.getCapabilities();\n        if (!capabilities.facingMode) {\n          return null;\n        }\n        return capabilities.facingMode.find(function (_) {\n          return type;\n        });\n      }),\n      _cameras$filter4 = _slicedToArray(_cameras$filter3, 1),\n      isCapable = _cameras$filter4[0];\n    return (isCapable == null ? void 0 : isCapable.deviceId) || (hasCamera == null ? void 0 : hasCamera.deviceId) || null;\n  });\n  return _supportsCameraType.apply(this, arguments);\n}","map":{"version":3,"names":["Platform","userMediaRequested","mountedInstances","requestLegacyUserMediaAsync","_x","_requestLegacyUserMediaAsync","apply","arguments","_asyncToGenerator","props","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","Array","isArray","_deviceId$","ideal","sources","Promise","resolve","MediaStreamTrack","getSources","audioSource","videoSource","forEach","source","kind","audioSourceId","audioConstraints","videoSourceId","videoConstraints","sourceSelectedAsync","_x2","_x3","_x4","_sourceSelectedAsync","isMuted","constraints","video","audio","getAnyUserMediaAsync","requestUserMediaAsync","_x5","_requestUserMediaAsync","length","undefined","canGetUserMedia","_yield$requestLegacyU","_yield$requestLegacyU2","_slicedToArray","_x6","_getAnyUserMediaAsync","ignoreConstraints","getUserMediaAsync","_objectSpread","error","name","_x7","_getUserMediaAsync","navigator","mediaDevices","getUserMedia","_getUserMedia","reject","call","isDOMAvailable","isFrontCameraAvailableAsync","_x8","_isFrontCameraAvailableAsync","devices","supportsCameraType","isBackCameraAvailableAsync","_x9","_isBackCameraAvailableAsync","_x0","_x1","_x10","_supportsCameraType","labels","type","enumerateDevices","cameras","filter","t","_cameras$filter","camera","some","label","toLowerCase","includes","_cameras$filter2","hasCamera","_cameras$filter3","capabilities","getCapabilities","facingMode","find","_","_cameras$filter4","isCapable"],"sources":["/Users/asearer/Documents/Projects/safety-suggestion-reporting-system/apps/mobile/node_modules/expo-camera/src/web/WebUserMediaManager.ts"],"sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audioConstraints?: any; videoConstraints?: any }\n): Promise<any[]> {\n  // TODO(@kitten): This is never type checked against DOM types\n  const optionalSource = (id: string | string[] | null) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint: MediaTrackConstraintSet) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId)) {\n      return deviceId[0] ?? null;\n    } else if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `audioConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const [audio, video] = await requestLegacyUserMediaAsync(props as any);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error: any) {\n    if (\n      !ignoreConstraints &&\n      typeof error === 'object' &&\n      error?.name === 'ConstraintNotSatisfiedError'\n    ) {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] ||\n    navigator['webkitGetUserMedia'] ||\n    // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n    navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  // TODO(@kitten): This is misaligned with the implementations in `expo-audio/src/AudioModule.web.ts` and `expo-av`\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}