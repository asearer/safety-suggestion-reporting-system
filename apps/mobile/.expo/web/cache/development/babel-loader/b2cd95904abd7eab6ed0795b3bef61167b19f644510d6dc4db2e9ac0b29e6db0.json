{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { Platform, UnavailabilityError } from 'expo-modules-core';\nimport { Component, createRef } from 'react';\nimport ExpoCamera from \"./ExpoCamera\";\nimport CameraManager from \"./ExpoCameraManager\";\nimport { ConversionTables, ensureNativeProps } from \"./utils/props\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar EventThrottleMs = 500;\nvar _PICTURE_SAVED_CALLBACKS = {};\nvar loggedRenderingChildrenWarning = false;\nvar _GLOBAL_PICTURE_ID = 1;\nfunction ensurePictureOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n  if (options.quality === undefined) {\n    options.quality = 1;\n  }\n  if (options.mirror) {\n    console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');\n  }\n  if (options.onPictureSaved) {\n    var id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;\n    options.id = id;\n    options.fastMode = true;\n  }\n  return options;\n}\nfunction ensureRecordingOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n  if (options.mirror) {\n    console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');\n  }\n  return options;\n}\nfunction _onPictureSaved(_ref) {\n  var nativeEvent = _ref.nativeEvent;\n  var id = nativeEvent.id,\n    data = nativeEvent.data;\n  var callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\nvar CameraView = function (_Component) {\n  function CameraView() {\n    var _this;\n    _classCallCheck(this, CameraView);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, CameraView, [].concat(args));\n    _this._cameraRef = createRef();\n    _this._lastEvents = {};\n    _this._lastEventsTimes = {};\n    _this._onCameraReady = function () {\n      if (_this.props.onCameraReady) {\n        _this.props.onCameraReady();\n      }\n    };\n    _this._onAvailableLensesChanged = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n      if (_this.props.onAvailableLensesChanged) {\n        _this.props.onAvailableLensesChanged(nativeEvent);\n      }\n    };\n    _this._onMountError = function (_ref3) {\n      var nativeEvent = _ref3.nativeEvent;\n      if (_this.props.onMountError) {\n        _this.props.onMountError(nativeEvent);\n      }\n    };\n    _this._onResponsiveOrientationChanged = function (_ref4) {\n      var nativeEvent = _ref4.nativeEvent;\n      if (_this.props.onResponsiveOrientationChanged) {\n        _this.props.onResponsiveOrientationChanged(nativeEvent);\n      }\n    };\n    _this._onObjectDetected = function (callback) {\n      return function (_ref5) {\n        var nativeEvent = _ref5.nativeEvent;\n        var type = nativeEvent.type;\n        if (_this._lastEvents[type] && _this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === _this._lastEvents[type] && new Date().getTime() - _this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n          return;\n        }\n        if (callback) {\n          callback(nativeEvent);\n          _this._lastEventsTimes[type] = new Date();\n          _this._lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n      };\n    };\n    _this._setReference = function (ref) {\n      if (ref) {\n        if (Platform.OS === 'web') {\n          _this._cameraHandle = ref;\n        }\n      }\n    };\n    return _this;\n  }\n  _inherits(CameraView, _Component);\n  return _createClass(CameraView, [{\n    key: \"getAvailablePictureSizesAsync\",\n    value: (function () {\n      var _getAvailablePictureSizesAsync = _asyncToGenerator(function* () {\n        var _yield$this$_cameraRe, _this$_cameraRef$curr;\n        return (_yield$this$_cameraRe = yield (_this$_cameraRef$curr = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr.getAvailablePictureSizes()) != null ? _yield$this$_cameraRe : [];\n      });\n      function getAvailablePictureSizesAsync() {\n        return _getAvailablePictureSizesAsync.apply(this, arguments);\n      }\n      return getAvailablePictureSizesAsync;\n    }())\n  }, {\n    key: \"getAvailableLensesAsync\",\n    value: (function () {\n      var _getAvailableLensesAsync = _asyncToGenerator(function* () {\n        var _yield$this$_cameraRe2, _this$_cameraRef$curr2;\n        return (_yield$this$_cameraRe2 = yield (_this$_cameraRef$curr2 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr2.getAvailableLenses()) != null ? _yield$this$_cameraRe2 : [];\n      });\n      function getAvailableLensesAsync() {\n        return _getAvailableLensesAsync.apply(this, arguments);\n      }\n      return getAvailableLensesAsync;\n    }())\n  }, {\n    key: \"getSupportedFeatures\",\n    value: function getSupportedFeatures() {\n      return {\n        isModernBarcodeScannerAvailable: CameraManager.isModernBarcodeScannerAvailable,\n        toggleRecordingAsyncAvailable: CameraManager.toggleRecordingAsyncAvailable\n      };\n    }\n  }, {\n    key: \"resumePreview\",\n    value: (function () {\n      var _resumePreview = _asyncToGenerator(function* () {\n        var _this$_cameraRef$curr3;\n        return (_this$_cameraRef$curr3 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr3.resumePreview();\n      });\n      function resumePreview() {\n        return _resumePreview.apply(this, arguments);\n      }\n      return resumePreview;\n    }())\n  }, {\n    key: \"pausePreview\",\n    value: (function () {\n      var _pausePreview = _asyncToGenerator(function* () {\n        var _this$_cameraRef$curr4;\n        return (_this$_cameraRef$curr4 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr4.pausePreview();\n      });\n      function pausePreview() {\n        return _pausePreview.apply(this, arguments);\n      }\n      return pausePreview;\n    }())\n  }, {\n    key: \"takePictureAsync\",\n    value: function () {\n      var _takePictureAsync = _asyncToGenerator(function* (options) {\n        var _this$_cameraRef$curr6;\n        var pictureOptions = ensurePictureOptions(options);\n        if (Platform.OS === 'ios' && options != null && options.pictureRef) {\n          var _this$_cameraRef$curr5;\n          return (_this$_cameraRef$curr5 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr5.takePictureRef == null ? void 0 : _this$_cameraRef$curr5.takePictureRef(options);\n        }\n        return (_this$_cameraRef$curr6 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr6.takePicture(pictureOptions);\n      });\n      function takePictureAsync(_x) {\n        return _takePictureAsync.apply(this, arguments);\n      }\n      return takePictureAsync;\n    }()\n  }, {\n    key: \"recordAsync\",\n    value: (function () {\n      var _recordAsync = _asyncToGenerator(function* (options) {\n        var _this$_cameraRef$curr7;\n        var recordingOptions = ensureRecordingOptions(options);\n        return (_this$_cameraRef$curr7 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr7.record(recordingOptions);\n      });\n      function recordAsync(_x2) {\n        return _recordAsync.apply(this, arguments);\n      }\n      return recordAsync;\n    }())\n  }, {\n    key: \"toggleRecordingAsync\",\n    value: (function () {\n      var _toggleRecordingAsync = _asyncToGenerator(function* () {\n        var _this$_cameraRef$curr8;\n        return (_this$_cameraRef$curr8 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr8.toggleRecording();\n      });\n      function toggleRecordingAsync() {\n        return _toggleRecordingAsync.apply(this, arguments);\n      }\n      return toggleRecordingAsync;\n    }())\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      var _this$_cameraRef$curr9;\n      (_this$_cameraRef$curr9 = this._cameraRef.current) == null ? void 0 : _this$_cameraRef$curr9.stopRecording();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var nativeProps = ensureNativeProps(this.props);\n      var onBarcodeScanned = this.props.onBarcodeScanned ? this._onObjectDetected(this.props.onBarcodeScanned) : undefined;\n      if (nativeProps.children && !loggedRenderingChildrenWarning) {\n        console.warn('The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.');\n        loggedRenderingChildrenWarning = true;\n      }\n      return _jsx(ExpoCamera, _objectSpread(_objectSpread({}, nativeProps), {}, {\n        ref: this._cameraRef,\n        onCameraReady: this._onCameraReady,\n        onMountError: this._onMountError,\n        onBarcodeScanned: onBarcodeScanned,\n        onAvailableLensesChanged: this._onAvailableLensesChanged,\n        onPictureSaved: _onPictureSaved,\n        onResponsiveOrientationChanged: this._onResponsiveOrientationChanged\n      }));\n    }\n  }], [{\n    key: \"isAvailableAsync\",\n    value: (function () {\n      var _isAvailableAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.isAvailableAsync) {\n          throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n        }\n        return CameraManager.isAvailableAsync();\n      });\n      function isAvailableAsync() {\n        return _isAvailableAsync.apply(this, arguments);\n      }\n      return isAvailableAsync;\n    }())\n  }, {\n    key: \"getAvailableVideoCodecsAsync\",\n    value: function () {\n      var _getAvailableVideoCodecsAsync = _asyncToGenerator(function* () {\n        if (!CameraManager.getAvailableVideoCodecsAsync) {\n          throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n        }\n        return CameraManager.getAvailableVideoCodecsAsync();\n      });\n      function getAvailableVideoCodecsAsync() {\n        return _getAvailableVideoCodecsAsync.apply(this, arguments);\n      }\n      return getAvailableVideoCodecsAsync;\n    }()\n  }, {\n    key: \"launchScanner\",\n    value: (function () {\n      var _launchScanner = _asyncToGenerator(function* (options) {\n        if (!options) {\n          options = {\n            barcodeTypes: []\n          };\n        }\n        if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n          yield CameraManager.launchScanner(options);\n        }\n      });\n      function launchScanner(_x3) {\n        return _launchScanner.apply(this, arguments);\n      }\n      return launchScanner;\n    }())\n  }, {\n    key: \"dismissScanner\",\n    value: (function () {\n      var _dismissScanner = _asyncToGenerator(function* () {\n        if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n          yield CameraManager.dismissScanner();\n        }\n      });\n      function dismissScanner() {\n        return _dismissScanner.apply(this, arguments);\n      }\n      return dismissScanner;\n    }())\n  }, {\n    key: \"onModernBarcodeScanned\",\n    value: function onModernBarcodeScanned(listener) {\n      return CameraManager.addListener('onModernBarcodeScanned', listener);\n    }\n  }]);\n}(Component);\nCameraView.isModernBarcodeScannerAvailable = CameraManager.isModernBarcodeScannerAvailable;\nCameraView.ConversionTables = ConversionTables;\nCameraView.defaultProps = {\n  zoom: 0,\n  facing: 'back',\n  enableTorch: false,\n  mode: 'picture',\n  flash: 'off'\n};\nexport { CameraView as default };","map":{"version":3,"names":["Platform","UnavailabilityError","Component","createRef","ExpoCamera","CameraManager","ConversionTables","ensureNativeProps","jsx","_jsx","EventThrottleMs","_PICTURE_SAVED_CALLBACKS","loggedRenderingChildrenWarning","_GLOBAL_PICTURE_ID","ensurePictureOptions","options","quality","undefined","mirror","console","warn","onPictureSaved","id","fastMode","ensureRecordingOptions","arguments","length","_onPictureSaved","_ref","nativeEvent","data","callback","CameraView","_Component","_this","_classCallCheck","_len","args","Array","_key","_callSuper","concat","_cameraRef","_lastEvents","_lastEventsTimes","_onCameraReady","props","onCameraReady","_onAvailableLensesChanged","_ref2","onAvailableLensesChanged","_onMountError","_ref3","onMountError","_onResponsiveOrientationChanged","_ref4","onResponsiveOrientationChanged","_onObjectDetected","_ref5","type","JSON","stringify","Date","getTime","_setReference","ref","OS","_cameraHandle","_inherits","_createClass","key","value","_getAvailablePictureSizesAsync","_asyncToGenerator","_yield$this$_cameraRe","_this$_cameraRef$curr","current","getAvailablePictureSizes","getAvailablePictureSizesAsync","apply","_getAvailableLensesAsync","_yield$this$_cameraRe2","_this$_cameraRef$curr2","getAvailableLenses","getAvailableLensesAsync","getSupportedFeatures","isModernBarcodeScannerAvailable","toggleRecordingAsyncAvailable","_resumePreview","_this$_cameraRef$curr3","resumePreview","_pausePreview","_this$_cameraRef$curr4","pausePreview","_takePictureAsync","_this$_cameraRef$curr6","pictureOptions","pictureRef","_this$_cameraRef$curr5","takePictureRef","takePicture","takePictureAsync","_x","_recordAsync","_this$_cameraRef$curr7","recordingOptions","record","recordAsync","_x2","_toggleRecordingAsync","_this$_cameraRef$curr8","toggleRecording","toggleRecordingAsync","stopRecording","_this$_cameraRef$curr9","render","nativeProps","onBarcodeScanned","children","_objectSpread","_isAvailableAsync","isAvailableAsync","_getAvailableVideoCodecsAsync","getAvailableVideoCodecsAsync","_launchScanner","barcodeTypes","launchScanner","_x3","_dismissScanner","dismissScanner","onModernBarcodeScanned","listener","addListener","defaultProps","zoom","facing","enableTorch","mode","flash","default"],"sources":["/Users/asearer/Documents/Projects/safety-suggestion-reporting-system/apps/mobile/node_modules/expo-camera/src/CameraView.tsx"],"sourcesContent":["import { Platform, UnavailabilityError, type EventSubscription } from 'expo-modules-core';\nimport { type Ref, Component, createRef } from 'react';\n\nimport {\n  CameraCapturedPicture,\n  CameraOrientation,\n  CameraPictureOptions,\n  CameraViewProps,\n  CameraRecordingOptions,\n  CameraViewRef,\n  ScanningOptions,\n  ScanningResult,\n  VideoCodec,\n  AvailableLenses,\n} from './Camera.types';\nimport ExpoCamera from './ExpoCamera';\nimport CameraManager from './ExpoCameraManager';\nimport { PictureRef } from './PictureRef';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS: Record<number, CameraPictureOptions['onPictureSaved'] | undefined> =\n  {};\n\nlet loggedRenderingChildrenWarning = false;\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.quality === undefined) {\n    options.quality = 1;\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  if (options.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;\n    options.id = id;\n    options.fastMode = true;\n  }\n\n  return options;\n}\n\nfunction ensureRecordingOptions(options: CameraRecordingOptions = {}): CameraRecordingOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  return options;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class CameraView extends Component<CameraViewProps> {\n  /**\n   * Property that determines if the current device has the ability to use `DataScannerViewController` (iOS 16+) or the Google code scanner (Android).\n   */\n  static isModernBarcodeScannerAvailable: boolean = CameraManager.isModernBarcodeScannerAvailable;\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return CameraManager.isAvailableAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  /**\n   * Get picture sizes that are supported by the device.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailablePictureSizes()) ?? [];\n  }\n\n  /**\n   * Returns the available lenses for the currently selected camera.\n   *\n   * @return Returns a Promise that resolves to an array of strings representing the lens type that can be passed to `selectedLens` prop.\n   * @platform ios\n   */\n  async getAvailableLensesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailableLenses()) ?? [];\n  }\n\n  /**\n   * Returns an object with the supported features of the camera on the current device.\n   */\n  getSupportedFeatures(): {\n    isModernBarcodeScannerAvailable: boolean;\n    toggleRecordingAsyncAvailable: boolean;\n  } {\n    return {\n      isModernBarcodeScannerAvailable: CameraManager.isModernBarcodeScannerAvailable,\n      toggleRecordingAsyncAvailable: CameraManager.toggleRecordingAsyncAvailable,\n    };\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  async resumePreview(): Promise<void> {\n    return this._cameraRef.current?.resumePreview();\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  async pausePreview(): Promise<void> {\n    return this._cameraRef.current?.pausePreview();\n  }\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraViewProps = {\n    zoom: 0,\n    facing: 'back',\n    enableTorch: false,\n    mode: 'picture',\n    flash: 'off',\n  };\n\n  _cameraHandle?: number | null;\n  _cameraRef = createRef<CameraViewRef>();\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  /**\n   * Takes a picture and returns an object that references the native image instance.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   *\n   * > **Note:** Avoid calling this method while the preview is paused. On Android, this will throw an error. On iOS, this will take a picture of the last frame that is currently on screen.\n   *\n   * @param optionsWithRef An object in form of `CameraPictureOptions` type and `pictureRef` key set to `true`.\n   * @return Returns a Promise that resolves to `PictureRef` class which contains basic image data, and a reference to native image instance which can be passed\n   * to other Expo packages supporting handling such an instance.\n   */\n  async takePictureAsync(\n    optionsWithRef: CameraPictureOptions & { pictureRef: true }\n  ): Promise<PictureRef>;\n\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   *\n   * > **Note:** Avoid calling this method while the preview is paused. On Android, this will throw an error. On iOS, this will take a picture of the last frame that is currently on screen.\n   *\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on Android,\n   * iOS, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image.\n   *\n   * `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64. Prepend it with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example.\n   *\n   * `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image. The names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copy`](filesystem/#copydestination-1)\n   * > to make a permanent copy of the image.\n   */\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture>;\n\n  async takePictureAsync(options?: CameraPictureOptions) {\n    const pictureOptions = ensurePictureOptions(options);\n\n    if (Platform.OS === 'ios' && options?.pictureRef) {\n      return this._cameraRef.current?.takePictureRef?.(options);\n    }\n    return this._cameraRef.current?.takePicture(pictureOptions);\n  }\n\n  /**\n   * On Android, we will use the [Google code scanner](https://developers.google.com/ml-kit/vision/barcode-scanning/code-scanner).\n   * On iOS, presents a modal view controller that uses the [`DataScannerViewController`](https://developer.apple.com/documentation/visionkit/scanning_data_with_the_camera) available on iOS 16+.\n   * @platform android\n   * @platform ios\n   */\n  static async launchScanner(options?: ScanningOptions): Promise<void> {\n    if (!options) {\n      options = { barcodeTypes: [] };\n    }\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.launchScanner(options);\n    }\n  }\n\n  /**\n   * Dismiss the scanner presented by `launchScanner`.\n   * > **info** On Android, the scanner is dismissed automatically when a barcode is scanned.\n   * @platform ios\n   */\n  static async dismissScanner(): Promise<void> {\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.dismissScanner();\n    }\n  }\n\n  /**\n   * Invokes the `listener` function when a bar code has been successfully scanned. The callback is provided with\n   * an object of the `ScanningResult` shape, where the `type` refers to the bar code type that was scanned and the `data` is the information encoded in the bar code\n   * (in this case of QR codes, this is often a URL). See [`BarcodeType`](#barcodetype) for supported values.\n   * @param listener Invoked with the [ScanningResult](#scanningresult) when a bar code has been successfully scanned.\n   *\n   * @platform ios\n   * @platform android\n   */\n  static onModernBarcodeScanned(listener: (event: ScanningResult) => void): EventSubscription {\n    return CameraManager.addListener('onModernBarcodeScanned', listener);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions) {\n    const recordingOptions = ensureRecordingOptions(options);\n    return this._cameraRef.current?.record(recordingOptions);\n  }\n\n  /**\n   * Pauses or resumes the video recording. Only has an effect if there is an active recording. On `iOS`, this method only supported on `iOS` 18.\n   *\n   * @example\n   * ```ts\n   * const { toggleRecordingAsyncAvailable } = getSupportedFeatures()\n   *\n   * return (\n   *  {toggleRecordingAsyncAvailable && (\n   *    <Button title=\"Toggle Recording\" onPress={toggleRecordingAsync} />\n   *  )}\n   * )\n   * ```\n   */\n  async toggleRecordingAsync() {\n    return this._cameraRef.current?.toggleRecording();\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   * @platform android\n   * @platform ios\n   */\n  stopRecording() {\n    this._cameraRef.current?.stopRecording();\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onAvailableLensesChanged = ({ nativeEvent }: { nativeEvent: AvailableLenses }) => {\n    if (this.props.onAvailableLensesChanged) {\n      this.props.onAvailableLensesChanged(nativeEvent);\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onResponsiveOrientationChanged = ({\n    nativeEvent,\n  }: {\n    nativeEvent: { orientation: CameraOrientation };\n  }) => {\n    if (this.props.onResponsiveOrientationChanged) {\n      this.props.onResponsiveOrientationChanged(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref: Ref<CameraViewRef>) => {\n    if (ref) {\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      }\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n    const onBarcodeScanned = this.props.onBarcodeScanned\n      ? this._onObjectDetected(this.props.onBarcodeScanned)\n      : undefined;\n\n    // @ts-expect-error\n    if (nativeProps.children && !loggedRenderingChildrenWarning) {\n      console.warn(\n        'The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.'\n      );\n      loggedRenderingChildrenWarning = true;\n    }\n\n    return (\n      <ExpoCamera\n        {...nativeProps}\n        ref={this._cameraRef}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarcodeScanned={onBarcodeScanned}\n        onAvailableLensesChanged={this._onAvailableLensesChanged}\n        onPictureSaved={_onPictureSaved}\n        onResponsiveOrientationChanged={this._onResponsiveOrientationChanged}\n      />\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}